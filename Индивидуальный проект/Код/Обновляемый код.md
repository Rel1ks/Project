#Yougile #YouGile #код #Проект
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Консольный текстовый редактор на Python - оптимизированная версия
"""

import curses
import locale
import os
import sys
import unicodedata
import glob
import subprocess
from typing import List, Tuple, Optional
from dataclasses import dataclass
from copy import deepcopy

# Мгновенная обработка ESC (до инициализации curses)
os.environ.setdefault('ESCDELAY', '10')


def char_width(char: str) -> int:
    if not char:
        return 0
    try:
        eaw = unicodedata.east_asian_width(char)
        if eaw in ('F', 'W'):
            return 2
    except:
        pass
    return 1


def get_clipboard() -> str:
    """Получить текст из системного буфера обмена"""
    try:
        # Попробовать wl-paste (Wayland)
        result = subprocess.run(['wl-paste'], capture_output=True, text=True, timeout=1)
        if result.returncode == 0:
            return result.stdout
    except:
        pass
    
    try:
        # Попробовать xclip (X11)
        result = subprocess.run(['xclip', '-selection', 'clipboard', '-o'], 
                              capture_output=True, text=True, timeout=1)
        if result.returncode == 0:
            return result.stdout
    except:
        pass
    
    try:
        # Попробовать xsel (X11)
        result = subprocess.run(['xsel', '-b', '-o'], capture_output=True, text=True, timeout=1)
        if result.returncode == 0:
            return result.stdout
    except:
        pass
    
    return ""


def set_clipboard(text: str) -> bool:
    """Записать текст в системный буфер обмена"""
    try:
        # Попробовать wl-copy (Wayland)
        result = subprocess.run(['wl-copy'], input=text, capture_output=True, text=True, timeout=1)
        if result.returncode == 0:
            return True
    except:
        pass
    
    try:
        # Попробовать xclip (X11)
        result = subprocess.run(['xclip', '-selection', 'clipboard', '-i'], 
                              input=text, capture_output=True, text=True, timeout=1)
        if result.returncode == 0:
            return True
    except:
        pass
    
    try:
        # Попробовать xsel (X11)
        result = subprocess.run(['xsel', '-b', '-i'], input=text, capture_output=True, text=True, timeout=1)
        if result.returncode == 0:
            return True
    except:
        pass
    
    return False


@dataclass
class EditorState:
    lines: List[str]
    cursor_x: int
    cursor_y: int


class Dialog:
    def __init__(self, title: str, prompt: str, initial_value: str = "", allow_tab_complete: bool = False):
        self.title = title
        self.prompt = prompt
        self.value = initial_value
        self.active = True
        self.cursor_pos = len(initial_value)
        self.allow_tab_complete = allow_tab_complete
        self._tab_matches: List[str] = []
    
    def draw(self, stdscr, height: int, width: int):
        dialog_width = min(60, width - 4)
        dialog_height = 5
        dialog_x = (width - dialog_width) // 2
        dialog_y = (height - dialog_height) // 2
        
        stdscr.attron(curses.color_pair(1))
        for i in range(dialog_height):
            stdscr.addstr(dialog_y + i, dialog_x, " " * dialog_width)
        
        title_display = f" {self.title} "
        title_x = dialog_x + (dialog_width - len(title_display)) // 2
        stdscr.addstr(dialog_y, dialog_x, "┌" + "─" * (dialog_width - 2) + "┐")
        stdscr.addstr(dialog_y + 1, dialog_x, "│")
        stdscr.addstr(dialog_y + 1, title_x, title_display)
        stdscr.addstr(dialog_y + 1, dialog_x + dialog_width - 1, "│")
        
        stdscr.addstr(dialog_y + 2, dialog_x, "│ " + self.prompt[:dialog_width - 6])
        stdscr.addstr(dialog_y + 2, dialog_x + dialog_width - 1, "│")
        
        input_y = dialog_y + 3
        stdscr.addstr(input_y, dialog_x, "│ ")
        
        visible_start = max(0, self.cursor_pos - (dialog_width - 6))
        visible_value = self.value[visible_start:visible_start + dialog_width - 6]
        cursor_screen_pos = self.cursor_pos - visible_start
        
        stdscr.attron(curses.A_REVERSE)
        stdscr.addstr(input_y, dialog_x + 2, visible_value.ljust(dialog_width - 6))
        stdscr.attroff(curses.A_REVERSE)
        
        stdscr.addstr(input_y, dialog_x + dialog_width - 1, "│")
        stdscr.addstr(dialog_y + 4, dialog_x, "└" + "─" * (dialog_width - 2) + "┘")
        stdscr.attroff(curses.color_pair(1))
        
        stdscr.move(input_y, dialog_x + 2 + cursor_screen_pos)
    
    def _tab_complete(self):
        if not self.allow_tab_complete:
            return
        
        path = self.value or "./"
        try:
            path = os.path.expanduser(path)
            if os.path.isdir(path):
                search_dir, prefix = path, ""
            else:
                search_dir = os.path.dirname(path) or "."
                prefix = os.path.basename(path)
            
            matches = sorted(glob.glob(os.path.join(search_dir, prefix + "*")))
            
            if matches:
                if not self._tab_matches:
                    self._tab_matches = matches
                match = self._tab_matches.pop(0)
                self._tab_matches.append(match)
                if os.path.isdir(match):
                    match += "/"
                self.value = match
                self.cursor_pos = len(self.value)
        except:
            pass
    
    def handle_key(self, key: int, char: Optional[str]) -> Tuple[bool, Optional[str]]:
        if key in (curses.KEY_ENTER, 10, 13):
            self.active = False
            return (True, self.value)
        elif key == 27:
            self.active = False
            return (True, None)
        elif key == 9:
            self._tab_complete()
        elif key in (curses.KEY_BACKSPACE, 8, 127, 263):
            if self.cursor_pos > 0:
                self.value = self.value[:self.cursor_pos - 1] + self.value[self.cursor_pos:]
                self.cursor_pos -= 1
                self._tab_matches = []
        elif key in (curses.KEY_DC, 330):
            if self.cursor_pos < len(self.value):
                self.value = self.value[:self.cursor_pos] + self.value[self.cursor_pos + 1:]
        elif key in (curses.KEY_LEFT, 260):
            if self.cursor_pos > 0:
                self.cursor_pos -= 1
        elif key in (curses.KEY_RIGHT, 261):
            if self.cursor_pos < len(self.value):
                self.cursor_pos += 1
        elif char:
            self.value = self.value[:self.cursor_pos] + char + self.value[self.cursor_pos:]
            self.cursor_pos += len(char)
            self._tab_matches = []
        
        return (False, None)


class FindDialog(Dialog):
    def __init__(self):
        super().__init__("Найти", "Найти:", "")


class GotoDialog(Dialog):
    def __init__(self, max_line: int):
        super().__init__("Перейти к строке", f"Строка (1-{max_line}):", "")
        self.max_line = max_line
    
    def handle_key(self, key: int, char: Optional[str]) -> Tuple[bool, Optional[int]]:
        done, result = super().handle_key(key, char)
        if done and result:
            try:
                line_num = int(result)
                return (True, line_num if 1 <= line_num <= self.max_line else None)
            except:
                return (True, None)
        return (done, result if result is None else None)


class TextEditor:
    def __init__(self, stdscr, filename: Optional[str] = None):
        self.stdscr = stdscr
        self.filename = filename or "Безымянный"
        self.lines: List[str] = [""]
        self.cursor_x = 0
        self.cursor_y = 0
        self.offset_x = 0
        self.offset_y = 0
        
        # Выделение
        self.select_start_x = 0
        self.select_start_y = 0
        self.select_end_x = 0
        self.select_end_y = 0
        self.selecting = False
        self.has_selection = False
        
        # Буфер обмена (внутренний + системный)
        self.clipboard = ""
        
        # История для Undo/Redo
        self.history: List[EditorState] = []
        self.history_index = -1
        self.max_history = 50
        self._last_saved_lines: List[str] = [""]
        
        self.modified = False
        self.search_query = ""
        self.search_results: List[Tuple[int, int]] = []
        self.current_search_result = -1
        self.status_message = ""
        self.status_color = 0
        self.dialog: Optional[Dialog] = None
        
        # Кэш
        self._screen_height = 0
        self._screen_width = 0
        
        self._setup_curses()
        
        if filename and os.path.exists(filename):
            self._load_file(filename)
        
        self._save_to_history()
    
    def _setup_curses(self):
        try:
            locale.setlocale(locale.LC_ALL, '')
        except:
            pass
        
        try:
            curses.set_escdelay(10)
        except:
            pass
        
        curses.raw()
        curses.noecho()
        curses.curs_set(1)
        self.stdscr.keypad(True)
        
        if curses.has_colors():
            curses.start_color()
            curses.use_default_colors()
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
            curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_CYAN)
            curses.init_pair(3, curses.COLOR_YELLOW, -1)
            curses.init_pair(4, curses.COLOR_RED, -1)
            curses.init_pair(5, curses.COLOR_GREEN, -1)
            curses.init_pair(6, curses.COLOR_WHITE, curses.COLOR_MAGENTA)  # Для выделения
    
    def _save_to_history(self):
        if self.lines == self._last_saved_lines:
            return
        
        self._last_saved_lines = self.lines.copy()
        
        if self.history_index < len(self.history) - 1:
            self.history = self.history[:self.history_index + 1]
        
        self.history.append(EditorState(
            lines=self.lines.copy(),
            cursor_x=self.cursor_x,
            cursor_y=self.cursor_y
        ))
        
        if len(self.history) > self.max_history:
            self.history.pop(0)
        else:
            self.history_index += 1
    
    def _load_file(self, filename: str):
        try:
            filename = os.path.expanduser(filename)
            with open(filename, 'r', encoding='utf-8') as f:
                self.lines = f.read().split('\n') or [""]
            self.filename = filename
            self.modified = False
        except FileNotFoundError:
            self.lines = [""]
            self.filename = filename
            self._set_status("Новый файл", color=5)
        except Exception as e:
            self._set_status(f"Ошибка: {e}", color=4)
    
    def _save_file(self, filename: Optional[str] = None):
        save_name = (filename or self.filename).strip()
        if not save_name or save_name == "Безымянный":
            self._set_status("Укажите имя файла", color=4)
            return False
        
        try:
            save_name = os.path.abspath(os.path.expanduser(save_name))
            dir_name = os.path.dirname(save_name)
            if dir_name and not os.path.exists(dir_name):
                os.makedirs(dir_name, exist_ok=True)
            
            with open(save_name, 'w', encoding='utf-8') as f:
                f.write('\n'.join(self.lines))
            
            self.filename = save_name
            self.modified = False
            self._set_status("Сохранено", color=5)
            return True
        except Exception as e:
            self._set_status(f"Ошибка: {e}", color=4)
            return False
    
    def _set_status(self, message: str, color: int = 0):
        self.status_message = message
        self.status_color = color
    
    def _zoom_in(self):
        """Увеличить масштаб"""
        # Escape-последовательности для терминалов которые поддерживают
        try:
            # Kitty
            sys.stdout.write("\x1b]50;Font=size+1\x07")
            sys.stdout.flush()
            self._set_status("Масштаб +", color=5)
        except:
            pass
    
    def _zoom_out(self):
        """Уменьшить масштаб"""
        try:
            # Kitty
            sys.stdout.write("\x1b]50;Font=size-1\x07")
            sys.stdout.flush()
            self._set_status("Масштаб -", color=5)
        except:
            pass
    
    def _zoom_reset(self):
        """Сбросить масштаб"""
        try:
            sys.stdout.write("\x1b]50;Font=size=12\x07")
            sys.stdout.flush()
            self._set_status("Масштаб сброшен", color=5)
        except:
            pass
    
    def _clamp_cursor(self):
        self.cursor_y = max(0, min(self.cursor_y, len(self.lines) - 1))
        self.cursor_x = max(0, min(self.cursor_x, len(self.lines[self.cursor_y])))
    
    def _update_scroll(self):
        height, width = self.stdscr.getmaxyx()
        edit_height = height - 2
        
        if self.cursor_y < self.offset_y:
            self.offset_y = self.cursor_y
        elif self.cursor_y >= self.offset_y + edit_height:
            self.offset_y = self.cursor_y - edit_height + 1
        
        line = self.lines[self.cursor_y]
        cursor_screen = sum(char_width(c) for c in line[:self.cursor_x])
        available = width - 6
        
        if cursor_screen < self.offset_x:
            self.offset_x = cursor_screen
        elif cursor_screen >= self.offset_x + available:
            self.offset_x = cursor_screen - available + 1
    
    def _get_selection_range(self) -> Tuple[int, int, int, int]:
        """Получить упорядоченный диапазон выделения"""
        if not self.has_selection:
            return (0, 0, 0, 0)
        
        if (self.select_start_y, self.select_start_x) <= (self.select_end_y, self.select_end_x):
            return (self.select_start_y, self.select_start_x, self.select_end_y, self.select_end_x)
        else:
            return (self.select_end_y, self.select_end_x, self.select_start_y, self.select_start_x)
    
    def _draw(self):
        height, width = self.stdscr.getmaxyx()
        self._screen_height = height
        self._screen_width = width
        
        self.stdscr.erase()
        
        edit_height = height - 2
        sel_y1, sel_x1, sel_y2, sel_x2 = self._get_selection_range()
        has_sel = self.has_selection
        
        for i in range(edit_height):
            line_num = self.offset_y + i
            y = i
            
            if line_num < len(self.lines):
                line = self.lines[line_num]
                num_str = f"{line_num + 1:4} "
                
                # Проверяем, есть ли выделение на этой строке
                in_selection = has_sel and sel_y1 <= line_num <= sel_y2
                
                if line_num == self.cursor_y:
                    self.stdscr.attrset(curses.color_pair(2))
                    self.stdscr.addstr(y, 0, " " * (width - 1))
                    self.stdscr.addstr(y, 0, num_str)
                    
                    text_start = 0
                    w = 0
                    while text_start < len(line) and w < self.offset_x:
                        w += char_width(line[text_start])
                        text_start += 1
                    
                    visible = line[text_start:]
                    try:
                        self.stdscr.addstr(y, 5, visible[:width - 7])
                    except:
                        pass
                elif in_selection:
                    # Строка с выделением
                    self.stdscr.attrset(curses.color_pair(6))  # magenta для выделения
                    self.stdscr.addstr(y, 0, " " * (width - 1))
                    self.stdscr.addstr(y, 0, num_str)
                    try:
                        self.stdscr.addstr(y, 5, line[:width - 7])
                    except:
                        pass
                else:
                    self.stdscr.attrset(0)
                    self.stdscr.addstr(y, 0, num_str)
                    try:
                        self.stdscr.addstr(y, 5, line[:width - 7])
                    except:
                        pass
            else:
                self.stdscr.attrset(0)
                self.stdscr.addstr(y, 0, "~")
        
        # Статус бар
        self.stdscr.attrset(curses.color_pair(1))
        mod = "*" if self.modified else ""
        left = f" {os.path.basename(self.filename)}{mod} "
        right = f" {self.cursor_y + 1}:{self.cursor_x + 1} "
        status = left + self.status_message[:width - len(left) - len(right) - 3].center(width - len(left) - len(right) - 2) + right
        self.stdscr.addstr(height - 2, 0, status[:width - 1].ljust(width - 1))
        
        # Подсказка
        self.stdscr.attrset(0)
        help_text = " ^S-сохр | ^O-откр | ^F-найти | ^A-всё | ^C/V/X-копир/встав/вырез | ^+/^- масштаб | ^Z-отмена | ^Q-выход"
        self.stdscr.addstr(height - 1, 0, help_text[:width - 1])
        
        # Диалог
        if self.dialog and self.dialog.active:
            self.dialog.draw(self.stdscr, height, width)
        else:
            line = self.lines[self.cursor_y]
            cursor_screen = sum(char_width(c) for c in line[:self.cursor_x])
            self.stdscr.move(
                self.cursor_y - self.offset_y,
                min(max(cursor_screen - self.offset_x + 5, 5), width - 2)
            )
        
        self.stdscr.refresh()
    
    def _insert_char(self, char: str):
        self.has_selection = False  # Сбросить выделение
        line = self.lines[self.cursor_y]
        self.lines[self.cursor_y] = line[:self.cursor_x] + char + line[self.cursor_x:]
        self.cursor_x += len(char)
        self.modified = True
    
    def _insert_newline(self):
        self.has_selection = False  # Сбросить выделение
        line = self.lines[self.cursor_y]
        self.lines[self.cursor_y] = line[:self.cursor_x]
        self.lines.insert(self.cursor_y + 1, line[self.cursor_x:])
        self.cursor_y += 1
        self.cursor_x = 0
        self.modified = True
        self._save_to_history()
    
    def _delete_char(self):
        self.has_selection = False  # Сбросить выделение
        if self.cursor_x > 0:
            line = self.lines[self.cursor_y]
            self.lines[self.cursor_y] = line[:self.cursor_x - 1] + line[self.cursor_x:]
            self.cursor_x -= 1
            self.modified = True
        elif self.cursor_y > 0:
            current = self.lines[self.cursor_y]
            prev = self.lines[self.cursor_y - 1]
            self.cursor_x = len(prev)
            self.lines[self.cursor_y - 1] = prev + current
            del self.lines[self.cursor_y]
            self.cursor_y -= 1
            self.modified = True
    
    def _delete_char_forward(self):
        self.has_selection = False  # Сбросить выделение
        line = self.lines[self.cursor_y]
        if self.cursor_x < len(line):
            self.lines[self.cursor_y] = line[:self.cursor_x] + line[self.cursor_x + 1:]
            self.modified = True
        elif self.cursor_y < len(self.lines) - 1:
            self.lines[self.cursor_y] = line + self.lines[self.cursor_y + 1]
            del self.lines[self.cursor_y + 1]
            self.modified = True
    
    def _move_cursor(self, direction: str):
        self.has_selection = False  # Сбросить выделение при навигации
        if direction == "up" and self.cursor_y > 0:
            self.cursor_y -= 1
        elif direction == "down" and self.cursor_y < len(self.lines) - 1:
            self.cursor_y += 1
        elif direction == "left":
            if self.cursor_x > 0:
                self.cursor_x -= 1
            elif self.cursor_y > 0:
                self.cursor_y -= 1
                self.cursor_x = len(self.lines[self.cursor_y])
        elif direction == "right":
            if self.cursor_x < len(self.lines[self.cursor_y]):
                self.cursor_x += 1
            elif self.cursor_y < len(self.lines) - 1:
                self.cursor_y += 1
                self.cursor_x = 0
        self._clamp_cursor()
    
    def _select_all(self):
        """Выделить всё"""
        self.select_start_y = 0
        self.select_start_x = 0
        self.select_end_y = len(self.lines) - 1
        self.select_end_x = len(self.lines[-1])
        self.has_selection = True
        # Переместить курсор в конец
        self.cursor_y = self.select_end_y
        self.cursor_x = self.select_end_x
        self._set_status("Выделено всё", color=5)
    
    def _copy(self):
        """Копировать выделенное или текущую строку"""
        if self.has_selection:
            sel_y1, sel_x1, sel_y2, sel_x2 = self._get_selection_range()
            if sel_y1 == sel_y2:
                text = self.lines[sel_y1][sel_x1:sel_x2]
            else:
                parts = [self.lines[sel_y1][sel_x1:]]
                for y in range(sel_y1 + 1, sel_y2):
                    parts.append(self.lines[y])
                parts.append(self.lines[sel_y2][:sel_x2])
                text = '\n'.join(parts)
        else:
            text = self.lines[self.cursor_y]
        
        self.clipboard = text
        if set_clipboard(text):
            self._set_status("Скопировано", color=5)
        else:
            self._set_status("Скопировано (внутр.)", color=5)
        
        self.has_selection = False
    
    def _cut(self):
        """Вырезать выделенное или текущую строку"""
        if self.has_selection:
            sel_y1, sel_x1, sel_y2, sel_x2 = self._get_selection_range()
            if sel_y1 == sel_y2:
                text = self.lines[sel_y1][sel_x1:sel_x2]
                self.lines[sel_y1] = self.lines[sel_y1][:sel_x1] + self.lines[sel_y1][sel_x2:]
            else:
                parts = [self.lines[sel_y1][sel_x1:]]
                for y in range(sel_y1 + 1, sel_y2):
                    parts.append(self.lines[y])
                parts.append(self.lines[sel_y2][:sel_x2])
                text = '\n'.join(parts)
                
                # Удалить выделенное
                self.lines[sel_y1] = self.lines[sel_y1][:sel_x1] + self.lines[sel_y2][sel_x2:]
                del self.lines[sel_y1 + 1:sel_y2 + 1]
            
            self.cursor_y = sel_y1
            self.cursor_x = sel_x1
        else:
            text = self.lines[self.cursor_y]
            if len(self.lines) > 1:
                del self.lines[self.cursor_y]
                if self.cursor_y >= len(self.lines):
                    self.cursor_y = len(self.lines) - 1
            else:
                self.lines[0] = ""
            self.cursor_x = 0
        
        self.clipboard = text
        set_clipboard(text)
        self._clamp_cursor()
        self.has_selection = False
        self.modified = True
        self._save_to_history()
        self._set_status("Вырезано", color=5)
    
    def _paste(self):
        """Вставить из буфера обмена"""
        # Сначала попробовать системный буфер
        text = get_clipboard()
        if not text:
            text = self.clipboard
        
        if not text:
            self._set_status("Буфер пуст", color=4)
            return
        
        # Удалить выделенное если есть
        if self.has_selection:
            sel_y1, sel_x1, sel_y2, sel_x2 = self._get_selection_range()
            if sel_y1 == sel_y2:
                self.lines[sel_y1] = self.lines[sel_y1][:sel_x1] + self.lines[sel_y1][sel_x2:]
            else:
                self.lines[sel_y1] = self.lines[sel_y1][:sel_x1] + self.lines[sel_y2][sel_x2:]
                del self.lines[sel_y1 + 1:sel_y2 + 1]
            
            self.cursor_y = sel_y1
            self.cursor_x = sel_x1
            self.has_selection = False
        
        if '\n' in text:
            parts = text.split('\n')
            line = self.lines[self.cursor_y]
            first = line[:self.cursor_x] + parts[0]
            last = parts[-1] + line[self.cursor_x:]
            self.lines[self.cursor_y] = first
            for i, part in enumerate(parts[1:-1], 1):
                self.lines.insert(self.cursor_y + i, part)
            self.lines.insert(self.cursor_y + len(parts) - 1, last)
            self.cursor_y += len(parts) - 1
            self.cursor_x = len(parts[-1])
        else:
            line = self.lines[self.cursor_y]
            self.lines[self.cursor_y] = line[:self.cursor_x] + text + line[self.cursor_x:]
            self.cursor_x += len(text)
        
        self._clamp_cursor()
        self.modified = True
        self._save_to_history()
        self._set_status("Вставлено", color=5)
    
    def _undo(self):
        if self.history_index > 0:
            self.history_index -= 1
            state = self.history[self.history_index]
            self.lines = state.lines.copy()
            self.cursor_x = state.cursor_x
            self.cursor_y = state.cursor_y
            self._clamp_cursor()
            self.modified = True
            self._set_status("Отменено", color=5)
    
    def _redo(self):
        if self.history_index < len(self.history) - 1:
            self.history_index += 1
            state = self.history[self.history_index]
            self.lines = state.lines.copy()
            self.cursor_x = state.cursor_x
            self.cursor_y = state.cursor_y
            self._set_status("Повторено", color=5)
    
    def _find(self, query: str):
        self.search_query = query
        self.search_results = []
        for i, line in enumerate(self.lines):
            pos = line.find(query)
            while pos != -1:
                self.search_results.append((i, pos))
                pos = line.find(query, pos + 1)
        
        if self.search_results:
            self.cursor_y, self.cursor_x = self.search_results[0]
            self._set_status(f"Найдено: {len(self.search_results)}", color=5)
        else:
            self._set_status("Не найдено", color=4)
    
    def _find_next(self):
        if self.search_results:
            self.current_search_result = (self.current_search_result + 1) % len(self.search_results)
            self.cursor_y, self.cursor_x = self.search_results[self.current_search_result]
    
    def _handle_key(self, key: int, char: Optional[str]) -> Optional[str]:
        if self.dialog and self.dialog.active:
            if isinstance(self.dialog, GotoDialog):
                done, result = self.dialog.handle_key(key, char)
                if done:
                    self.dialog = None
                    if result:
                        self.cursor_y = min(result - 1, len(self.lines) - 1)
                        self.cursor_x = 0
                    return None
            elif isinstance(self.dialog, Dialog):
                done, result = self.dialog.handle_key(key, char)
                if done:
                    title = self.dialog.title
                    self.dialog = None
                    if result:
                        if "Открыть" in title:
                            self._load_file(result)
                        elif "Сохранить" in title:
                            self._save_file(result)
                        elif "Найти" in title:
                            self._find(result)
                    return None
            return None
        
        # Навигация
        if key == curses.KEY_UP:
            self._move_cursor("up")
        elif key == curses.KEY_DOWN:
            self._move_cursor("down")
        elif key == curses.KEY_LEFT:
            self._move_cursor("left")
        elif key == curses.KEY_RIGHT:
            self._move_cursor("right")
        elif key == curses.KEY_HOME:
            self.has_selection = False
            self.cursor_x = 0
        elif key == curses.KEY_END:
            self.has_selection = False
            self.cursor_x = len(self.lines[self.cursor_y])
        elif key == curses.KEY_PPAGE:
            self.has_selection = False
            self.cursor_y = max(0, self.cursor_y - 10)
        elif key == curses.KEY_NPAGE:
            self.has_selection = False
            self.cursor_y = min(len(self.lines) - 1, self.cursor_y + 10)
        # Редактирование
        elif key in (curses.KEY_BACKSPACE, 8, 127, 263):
            self._delete_char()
        elif key == curses.KEY_DC:
            self._delete_char_forward()
        elif key in (curses.KEY_ENTER, 10, 13):
            self._insert_newline()
        # Команды
        elif key == 19:  # Ctrl+S
            self.dialog = Dialog("Сохранить файл", "Файл:", 
                                self.filename if self.filename != "Безымянный" else os.getcwd() + "/",
                                allow_tab_complete=True)
        elif key == 15:  # Ctrl+O
            self.dialog = Dialog("Открыть файл", "Путь:",
                                self.filename if self.filename != "Безымянный" else "",
                                allow_tab_complete=True)
        elif key == 6:  # Ctrl+F
            self.dialog = FindDialog()
        elif key == curses.KEY_F3:
            self._find_next()
        elif key == 7:  # Ctrl+G
            self.dialog = GotoDialog(len(self.lines))
        elif key == 26:  # Ctrl+Z
            self._undo()
        elif key == 25:  # Ctrl+Y
            self._redo()
        elif key in (43, 61):  # Ctrl++ или Ctrl+= (увеличить)
            self._zoom_in()
        elif key in (45, 95, 31):  # Ctrl+- или Ctrl+_ (уменьшить)
            self._zoom_out()
        elif key == 48:  # Ctrl+0 (сбросить масштаб)
            self._zoom_reset()
        elif key == 17:  # Ctrl+Q
            if self.modified:
                self._set_status("Сохраните файл! (Ctrl+S)", color=4)
            else:
                return "quit"
        elif char:
            self._insert_char(char)
        
        return None
    
    def run(self):
        while True:
            self._update_scroll()
            self._draw()
            
            try:
                key = self.stdscr.getch()
            except:
                break
            
            char = None
            
            if key == 27:  # Esc
                if self.dialog and self.dialog.active:
                    self.dialog = None
                    continue
                # Сбросить выделение
                self.has_selection = False
            
            # Обработка Ctrl комбинаций напрямую
            if key == 1:  # Ctrl+A - выделить всё
                self._select_all()
                continue
            elif key == 3:  # Ctrl+C - копировать
                self._copy()
                continue
            elif key == 22:  # Ctrl+V - вставить
                self._paste()
                continue
            elif key == 24:  # Ctrl+X - вырезать
                self._cut()
                continue
            
            if 32 <= key <= 126:
                char = chr(key)
            elif key >= 128:
                if key < 224:
                    b2 = self.stdscr.getch()
                    if b2 >= 128:
                        try:
                            char = bytes([key, b2]).decode('utf-8')
                        except:
                            pass
                elif key < 240:
                    b2, b3 = self.stdscr.getch(), self.stdscr.getch()
                    if b2 >= 128 and b3 >= 128:
                        try:
                            char = bytes([key, b2, b3]).decode('utf-8')
                        except:
                            pass
            
            if self._handle_key(key, char) == "quit":
                return


def run_editor():
    try:
        locale.setlocale(locale.LC_ALL, '')
    except:
        pass
    
    filename = sys.argv[1] if len(sys.argv) > 1 else None
    curses.wrapper(lambda stdscr: TextEditor(stdscr, filename).run())


if __name__ == "__main__":
    run_editor()
```